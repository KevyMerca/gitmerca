#!/bin/bash

# Source utilities
source "$(dirname "${BASH_SOURCE[0]}")/../utils/core-utils.sh"
source "$(dirname "${BASH_SOURCE[0]}")/../utils/git-utils.sh"
source "$(dirname "${BASH_SOURCE[0]}")/../utils/version.sh"

# Set Git's exec-path to help Git find man pages
export GIT_EXEC_PATH="$(dirname "${BASH_SOURCE[0]}"):$(git --exec-path)"

# Show version information
show_version() {
    show_command_version "Merca" "Custom git commands for mercateam contributors"
}

# Show usage information
show_usage() {
    # Format help output in a way that our man page generator can parse
    cat << EOF
git-merca - Git extension commands for mercateam contributors

Usage: git merca [command] [options]

Description:
    Suite of custom git commands for mercateam contributors.
    Provides tools for branch management, pull requests, and more.
    
Commands:
    update              Update gitmerca to the latest version
    uninstall          Remove gitmerca from your system
    doctor             Check installation health and dependencies
    list              Show all available commands
    config            View or edit configuration
    help              Show this help message

Options:
    -v, --version     Show version information
    -h, --help        Show this help message

Examples:
    git merca --version          # Show version
    git merca update            # Update to latest version
    git merca doctor            # Check installation

See git help merca for full documentation
EOF
    exit 0
}

# Function to update gitmerca
do_update() {
    print_info "üîÑ Checking for updates..."
    
    # Store current directory
    local current_dir
    current_dir=$(pwd)
    
    # Validate installation directory
    if [ ! -d "$INSTALL_DIR" ]; then
        error_exit "Installation directory not found at $INSTALL_DIR"
    fi
    
    # Initialize/check git repository
    if [ ! -d "$INSTALL_DIR/.git" ]; then
        print_info "üì¶ Setting up git repository..."
        local temp_dir
        temp_dir=$(mktemp -d) || error_exit "Failed to create temporary directory"
        
        # Get repository URL from current repo or use default
        local repo_url
        repo_url=$(git config --get remote.origin.url || echo "https://github.com/KevyMerca/gitmerca.git")
        
        if ! git clone "$repo_url" "$temp_dir"; then
            rm -rf "$temp_dir"
            error_exit "Failed to clone gitmerca repository from $repo_url"
        fi
        
        # Backup current config
        local config_backup
        config_backup=$(mktemp) || error_exit "Failed to create config backup"
        if [ -f "$INSTALL_DIR/config.json" ]; then
            cp "$INSTALL_DIR/config.json" "$config_backup"
        fi
        
        # Move contents to installation directory
        if ! cp -R "$temp_dir/." "$INSTALL_DIR/"; then
            rm -rf "$temp_dir" "$config_backup"
            error_exit "Failed to copy repository contents"
        fi
        
        # Restore config if it existed
        if [ -f "$config_backup" ]; then
            cp "$config_backup" "$INSTALL_DIR/config.json"
        fi
        
        # Cleanup
        rm -rf "$temp_dir" "$config_backup"
    fi
    
    # Navigate to installation directory
    cd "$INSTALL_DIR" || error_exit "Cannot find gitmerca installation directory"
    
    # Stash any local changes
    if ! git diff --quiet HEAD; then
        print_warning "Local changes detected, stashing them..."
        if ! git stash; then
            cd "$current_dir"
            error_exit "Failed to stash local changes"
        fi
    fi
    
    # Fetch latest changes
    if ! git fetch origin --tags --prune; then
        cd "$current_dir"
        error_exit "Failed to fetch updates"
    fi
    
    # Get latest version
    local latest_tag
    latest_tag=$(git describe --tags "$(git rev-list --tags --max-count=1 2>/dev/null)" 2>/dev/null)
    if [ -z "$latest_tag" ]; then
        cd "$current_dir"
        error_exit "No version tags found"
    fi
    
    local current_version
    current_version=$(get_version)
    
    if [ "$current_version" = "$latest_tag" ]; then
        print_success "You're already on the latest version ($current_version)"
        cd "$current_dir"
        return 0
    fi
    
    print_info "üì¶ Updating from $current_version to $latest_tag..."
    
    # Checkout latest version
    if ! git checkout "$latest_tag"; then
        cd "$current_dir"
        error_exit "Failed to checkout latest version"
    fi
    
    # Run installation
    if ! ./install.sh; then
        cd "$current_dir"
        error_exit "Failed to install new version"
    fi
    
    print_success "Successfully updated to $latest_tag"
    
    # Return to original directory
    cd "$current_dir" || error_exit "Failed to return to original directory"
}

# Function to check installation health
do_doctor() {
    print_info "üîç Running health checks..."
    local has_errors=0
    
    # Check installation directory
    if [ -d "$INSTALL_DIR" ]; then
        print_success "Installation directory found"
    else
        print_error "Installation directory not found"
        has_errors=1
    fi
    
    # Check PATH setup
    if echo "$PATH" | grep -q "$INSTALL_DIR/src/commands"; then
        print_success "PATH is correctly configured"
    else
        print_error "PATH is not properly configured"
        print_warning "Add '$INSTALL_DIR/src/commands' to your PATH"
        has_errors=1
    fi
    
    # Check git
    if command -v git >/dev/null 2>&1; then
        print_success "Git is installed $(git --version)"
    else
        print_error "Git is not installed"
        print_warning "Please install git to use gitmerca"
        has_errors=1
    fi
    
    # Check commands
    print_header "üìä Available commands:"
    local cmd_count=0
    while IFS= read -r cmd; do
        cmd_name=$(basename "$cmd" | sed 's/^git-//')
        if [ "$cmd_name" != "$(basename "${BASH_SOURCE[0]}" | sed 's/^git-//')" ]; then
            print_success "git $cmd_name"
            ((cmd_count++))
        fi
    done < <(ls -1 "$(dirname "${BASH_SOURCE[0]}")/git-"* 2>/dev/null)
    
    if [ $cmd_count -eq 0 ]; then
        print_warning "No additional commands found"
        has_errors=1
    fi
    
    return $has_errors
}

# Function to list available commands
do_list() {
    print_header "üìã Available commands:"
    echo ""
    print_header "Core Commands:"
    echo "  cleanup    Remove all local branches except develop"
    echo "  reform     Rebase and optionally switch branches"
    echo "  wrapup     Prepare and create a pull request"
    echo ""
    print_header "Meta Commands:"
    echo "  merca update     Update gitmerca to latest version"
    echo "  merca doctor     Check installation health"
    echo "  merca list       Show this list"
    echo "  merca config     View/edit configuration"
    echo ""
    echo "Use 'git <command> --help' for more information about a command"
}

# Function to handle configuration
do_config() {
    print_info "‚öôÔ∏è  Configuration:"
    print_header "Coming soon!"
}

# Main function
main() {
    # Parse arguments
    case $1 in
        update)
            do_update
            ;;
        uninstall)
            if [ -f "$INSTALL_DIR/uninstall.sh" ]; then
                "$INSTALL_DIR/uninstall.sh"
            else
                error_exit "Uninstall script not found"
            fi
            ;;
        doctor)
            do_doctor
            ;;
        list)
            do_list
            ;;
        config)
            do_config
            ;;
        -v|--version)
            show_version
            ;;
        help|-h|--help)
            show_usage
            ;;
        "")
            show_usage
            ;;
        *)
            error_exit "Unknown command: $1. Use --help for usage information."
            ;;
    esac
}

# Check for help flag first
if [[ "$1" == "--help" ]] || [[ "$1" == "-h" ]]; then
    show_usage
fi

# Run the main function with all arguments
main "$@"
